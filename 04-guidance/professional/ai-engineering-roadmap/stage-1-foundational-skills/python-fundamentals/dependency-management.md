# ðŸ§© Modern Python Dependency Management: Poetry vs Pipenv (2025)

Python dependency management has evolved significantly. In 2025, developers have multiple modern tools beyond basic pip and requirements.txt. This guide covers the ecosystem of dependency management tools, their use cases, and best practices.

**â† Back to**: [Python Fundamentals](./README.md)

---

## ðŸ“š What You'll Learn

### The Dependency Management Landscape

Python's dependency management ecosystem includes several tools, each solving different problems.

**Tool Comparison (2025):**

| Tool | Type | Best For | Speed | Standards |
|------|------|----------|-------|-----------|
| **pip** | Installer | Basic projects | Fast | PEP 517/518 |
| **pip-tools** | Lock file generator | Production pinning | Fast | Works with pip |
| **uv** | Ultra-fast installer | All use cases | **Fastest** | PEP 517/518 |
| **Poetry** | Full project manager | Libraries, publishing | Medium | PEP 621 |
| **PDM** | Modern manager | PEP 582, modern workflow | Fast | PEP 621 |
| **Pipenv** | Env + deps | Legacy enterprise | Slow | Pipfile spec |

---

### Traditional: pip + requirements.txt

The classic approach still works for simple projects but has significant limitations.

**Basic Workflow:**

```bash
# Create virtual environment
python -m venv .venv
source .venv/bin/activate

# Install dependencies
pip install requests pydantic numpy

# Save installed packages
pip freeze > requirements.txt

# Install from requirements
pip install -r requirements.txt
```

**requirements.txt Example:**

```
requests==2.31.0
pydantic==2.7.4
numpy==1.26.4
charset-normalizer==3.3.2  # Transitive dependency
idna==3.7                  # Transitive dependency
certifi==2024.7.4         # Transitive dependency
```

**Problems with pip + requirements.txt:**

- âŒ No automatic dependency resolution
- âŒ Manual version management
- âŒ Mixes direct and transitive dependencies
- âŒ No distinction between lockfile and direct dependencies
- âŒ Difficult to upgrade individual packages without breaking others
- âŒ Not reproducible across Python versions

---

### Modern Approach: pip-tools

Separates direct dependencies from locked versions for better reproducibility.

**Installation:**

```bash
pip install pip-tools
```

**Two-File System:**

**requirements.in** (direct dependencies only):

```
requests>=2.31
pydantic>=2.7
numpy>=1.26
```

**Generate locked requirements.txt:**

```bash
pip-compile requirements.in
```

**Generated requirements.txt** (with all transitive dependencies and annotations):

```
# This file is autogenerated by pip-compile with Python 3.12
# by the following command:
#
#    pip-compile requirements.in
#
certifi==2024.7.4
    # via requests
charset-normalizer==3.3.2
    # via requests
idna==3.7
    # via requests
numpy==1.26.4
pydantic==2.7.4
requests==2.31.0
urllib3==2.2.1
    # via requests
```

**Workflow:**

```bash
# Install from locked file (reproducible)
pip-sync requirements.txt

# Add new package
echo "flask>=2.0" >> requirements.in
pip-compile requirements.in

# Upgrade specific package
pip-compile --upgrade-package requests requirements.in
```

**Advantages:**

- âœ… Simple and fast
- âœ… Works with standard pip
- âœ… Clear separation of direct vs transitive dependencies
- âœ… Easy to review lockfile changes in git
- âœ… Reproducible across machines and CI/CD
- âœ… Minimal learning curve

**When to Use:**
- Simple projects with few dependencies
- Production deployments requiring reliability
- Projects that don't need to publish packages

---

### uv - The Fastest Tool (2025)

uv is a Rust-based Python package installer that's 10-100x faster than pip. It's becoming the standard for new Python projects.

**Installation:**

```bash
# Install uv (standalone)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Or with pip
pip install uv
```

**Basic Usage (drop-in pip replacement):**

```bash
# Create and activate venv
uv venv
source .venv/bin/activate

# Install packages (blazingly fast)
uv pip install requests pydantic numpy

# Install from requirements
uv pip install -r requirements.txt

# Compile requirements (like pip-tools)
uv pip compile requirements.in -o requirements.txt

# Sync environment
uv pip sync requirements.txt
```

**Performance Comparison:**

```
Install 100 packages from PyPI:
  pip:      ~120 seconds
  uv:       ~5 seconds (24x faster!)

Resolve dependencies for Flask:
  pip:      ~8 seconds
  uv:       ~0.3 seconds (26x faster!)
```

**Why uv?**

- âœ… **Speed**: 10-100x faster than pip
- âœ… **Compatibility**: Drop-in replacement for pip
- âœ… **Modern**: Built-in support for pyproject.toml
- âœ… **Reliable**: Proper dependency resolution
- âœ… **Future-proof**: Written in Rust, actively developed by Astral

**uv vs pip-tools:**

```bash
# Both are fast and produce identical results
# uv is simpler to use and doesn't require separate tool

# pip-tools
pip install pip-tools
pip-compile requirements.in
pip-sync requirements.txt

# uv (all in one)
uv pip compile requirements.in
uv pip sync requirements.txt
```

**When to Use:**
- All modern projects (it's a drop-in replacement for pip)
- Development and production
- Simple workflows to complex ones

---

### Poetry - Full Project Management

Poetry handles dependencies, virtual environments, build, and publishing in one integrated tool.

**Installation:**

```bash
# Install Poetry (recommended method)
curl -sSL https://install.python-poetry.org | python3 -

# Or with pip
pip install poetry
```

**Initialize New Project:**

```bash
# Create new project from scratch
poetry new my-project

# Or initialize in existing directory
cd existing-project
poetry init
```

**pyproject.toml (Poetry Format):**

```toml
[tool.poetry]
name = "my-project"
version = "0.1.0"
description = "My awesome project"
authors = ["Your Name <you@example.com>"]
readme = "README.md"
license = "MIT"

[tool.poetry.dependencies]
python = "^3.11"
requests = "^2.31"
pydantic = "^2.7"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4"
pytest-cov = "^4.1"
mypy = "^1.7"
ruff = "^0.1"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

**Common Commands:**

```bash
# Add dependency
poetry add requests

# Add dev dependency
poetry add --group dev pytest

# Install all dependencies
poetry install

# Install without dev dependencies
poetry install --only main

# Update all dependencies
poetry update

# Update specific package
poetry update requests

# Show dependency tree
poetry show --tree

# Run command in venv
poetry run python script.py

# Activate shell
poetry shell

# Build package
poetry build

# Publish to PyPI
poetry publish
```

**Version Constraints:**

```toml
# Caret (compatible versions): ^2.7 means >=2.7.0,<3.0.0
requests = "^2.31"

# Tilde (patch updates): ~2.31 means >=2.31.0,<2.32.0
requests = "~2.31"

# Exact version
requests = "2.31.0"

# Ranges
requests = ">=2.31,<3.0"

# Wildcard
requests = "2.*"
```

**poetry.lock File:**

- Automatically generated
- Pins all dependencies (including transitive)
- Ensures reproducible installs across machines
- **Always commit to git** for consistent team environments

**Advantages:**

- âœ… All-in-one solution (deps, build, publish, version management)
- âœ… Intelligent dependency resolver
- âœ… Automatic virtual environment creation and management
- âœ… Built-in build and publish tools
- âœ… Plugin system for extensions
- âœ… Great for publishing libraries to PyPI
- âœ… Excellent documentation

**Disadvantages:**

- âŒ Slower than pip-tools or uv (still acceptable)
- âŒ Learning curve for complex projects
- âŒ Sometimes too opinionated about project structure
- âŒ Overkill for simple scripts

**When to Use Poetry:**
- Publishing libraries to PyPI
- Large projects with complex dependencies
- Teams needing full-featured dependency management
- Projects with build and publishing requirements

---

### PDM - Modern Python Package Manager

PDM is a modern alternative supporting PEP 582 (packages without virtualenv) and modern standards.

**Installation:**

```bash
# Install PDM
curl -sSL https://pdm-project.org/install-pdm.py | python3 -

# Or with pip
pip install pdm
```

**Initialize Project:**

```bash
pdm init
```

**pyproject.toml (PDM Format - PEP 621):**

```toml
[project]
name = "my-project"
version = "0.1.0"
description = "My project"
requires-python = ">=3.11"
dependencies = [
    "requests>=2.31",
    "pydantic>=2.7",
]

[project.optional-dependencies]
test = ["pytest>=7.0", "pytest-cov>=4.1"]
dev = ["mypy>=1.7", "ruff>=0.1"]

[tool.pdm]
```

**Commands:**

```bash
# Add dependency
pdm add requests

# Add dev dependency
pdm add -dG test pytest

# Install dependencies
pdm install

# Update dependencies
pdm update

# Run script
pdm run python script.py

# Show dependency tree
pdm show --graph
```

**PEP 582 Mode (No venv!):**

```bash
# Enable PEP 582 (packages in __pypackages__)
pdm config python.use_venv false

# Packages installed in __pypackages__/3.12/lib/
# No need to activate venv - PDM handles it automatically
```

**Advantages:**

- âœ… Modern standards-based (PEP 621)
- âœ… Good monorepo support (multiple projects)
- âœ… PEP 582 mode eliminates need for virtualenv
- âœ… Fast dependency resolution
- âœ… Simpler config than Poetry

**When to Use PDM:**
- Modern projects wanting standards-based config
- Monorepos with multiple projects
- Organizations exploring PEP 582
- Projects that want minimal overhead

---

### Pipenv - Legacy Tool (Not Recommended)

Pipenv was popular but is now considered slow and problematic. **Avoid for new projects.**

**Installation:**

```bash
pip install pipenv
```

**Basic Usage:**

```bash
# Install package
pipenv install requests

# Install dev dependency
pipenv install --dev pytest

# Install from Pipfile
pipenv install

# Activate shell
pipenv shell

# Run command
pipenv run python script.py
```

**Pipfile Example:**

```toml
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
requests = "*"
pydantic = "*"

[dev-packages]
pytest = "*"

[requires]
python_version = "3.11"
```

**Why NOT Pipenv (2025)?**

- âŒ **Slow**: Much slower than alternatives (worse than pip!)
- âŒ **Bugs**: History of dependency resolver issues
- âŒ **Stagnant**: Less active development than Poetry, PDM, uv
- âŒ **Better Alternatives**: uv, Poetry, PDM are all faster and more reliable
- âŒ **Non-standard**: Uses Pipfile instead of PEP 621 standard

**Only use if required by legacy corporate policy.**

---

### Choosing the Right Tool

**Decision Matrix:**

| Scenario | Recommended Tool | Why |
|----------|------------------|-----|
| **Simple script/project** | pip + venv | Minimal overhead, built-in |
| **Production deployment** | pip-tools or uv | Reproducible, fast, reliable |
| **Need maximum speed** | **uv** | 10-100x faster than pip |
| **Publishing library to PyPI** | Poetry | Built-in build and publish |
| **Modern full-featured workflow** | Poetry or PDM | Standards-based, complete |
| **Team collaboration** | Poetry or PDM | Lockfiles, clear deps, reproducible |
| **Legacy corporate environment** | Pipenv (if mandated) | Sometimes required by policy |
| **Monorepo with multiple projects** | PDM | Better workspace support |
| **Speed is critical** | uv | Fastest option by far |

---

### Best Practices

**1. Always Use Lockfiles:**

```bash
# pip-tools
pip-compile requirements.in

# uv
uv pip compile requirements.in -o requirements.txt

# Poetry
poetry lock

# PDM
pdm lock
```

**Never commit unpinned dependencies to production.**

**2. Separate Direct from Transitive Dependencies:**

```toml
# Direct dependencies (what you actually use)
dependencies = [
    "requests",      # You import this
    "pydantic",      # You import this
]

# Transitive dependencies are handled by lockfile
# (urllib3, certifi, etc. - don't list these)
```

**3. Use Dependency Groups:**

```toml
[project.optional-dependencies]
test = ["pytest>=7.0", "pytest-cov>=4.1"]
lint = ["ruff>=0.1", "mypy>=1.7"]
docs = ["mkdocs>=1.4", "mkdocs-material>=9.0"]
dev = ["my-project[test,lint,docs]"]  # All tools
```

**4. Pin Production, Flexible Development:**

```toml
# Production (strict pinning)
dependencies = [
    "requests==2.31.0",
    "pydantic==2.7.4",
]

# Development (flexible for updates)
[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "mypy>=1.7",
]
```

**5. Document Environment Setup:**

```markdown
# Development Setup

## Using uv (recommended)
```bash
uv venv
source .venv/bin/activate  # Linux/macOS
.venv\Scripts\activate     # Windows
uv pip install -r requirements.txt
```

## Using Poetry
```bash
poetry install
poetry shell
```

## Using pip-tools
```bash
python -m venv .venv
source .venv/bin/activate
pip-sync requirements.txt
```
```

---

### Migration Strategies

**From requirements.txt to pip-tools:**

```bash
# Rename requirements.txt to requirements.in
mv requirements.txt requirements.in

# Compile to locked requirements.txt
pip-compile requirements.in
```

**From requirements.txt to Poetry:**

```bash
# Initialize Poetry
poetry init

# Add dependencies manually from requirements.txt
# Or edit pyproject.toml directly with each dependency
poetry lock
poetry install
```

**From Poetry to uv:**

```bash
# Export Poetry dependencies
poetry export -f requirements.txt -o requirements.txt

# Use with uv
uv pip sync requirements.txt
```

**From Pipenv to Poetry:**

```bash
# Export Pipenv
pipenv requirements > requirements.txt
pipenv requirements --dev > requirements-dev.txt

# Import to Poetry
poetry init
cat requirements.txt | xargs poetry add
cat requirements-dev.txt | xargs poetry add --group dev
```

---

### Handling Common Scenarios

**Scenario 1: Upgrade Security Fix**

```bash
# pip-tools
pip-compile --upgrade-package requests requirements.in

# uv
uv pip compile --upgrade-package requests requirements.in

# Poetry
poetry update requests

# PDM
pdm update requests
```

**Scenario 2: Local Development Package**

```bash
# Editable install with pip
pip install -e /path/to/local/package

# Poetry
poetry add /path/to/local/package
# Or in pyproject.toml:
# my-package = { path = "../my-package", develop = true }

# PDM
pdm add -e /path/to/local/package
```

**Scenario 3: Private PyPI Repository**

```bash
# pip
pip install --index-url https://private.pypi.org/simple/ package-name

# Poetry
# Add to pyproject.toml:
[[tool.poetry.source]]
name = "private"
url = "https://private.pypi.org/simple/"
priority = "supplemental"

# PDM
# Add to .pdm-python
[tool.pdm]
[[tool.pdm.source]]
url = "https://private.pypi.org/simple/"
name = "private"
verify_ssl = true
```

**Scenario 4: Pin Python Version**

```toml
# Poetry
[tool.poetry.dependencies]
python = "^3.11"  # >= 3.11, < 4.0

# PDM
[project]
requires-python = ">=3.11,<4.0"

# pip / pip-tools
# Create .python-version file
echo "3.11.0" > .python-version
```

---

### Dependency Security

**Check for vulnerabilities:**

```bash
# pip-audit (works with all tools)
pip install pip-audit
pip-audit

# Safety (alternative)
pip install safety
safety check

# Poetry built-in
poetry update --dry-run
```

**Set up automated updates:**

- Use **Dependabot** (GitHub) for automatic PR updates
- Use **Renovate** for more advanced automation
- Review and test updates regularly

---

## ðŸ”— Learning Resources

### Official Documentation

- [pip Documentation](https://pip.pypa.io/) - Python package installer
- [pip-tools GitHub](https://github.com/jazzband/pip-tools) - Dependency pinning
- [uv Documentation](https://github.com/astral-sh/uv) - Ultra-fast Python package installer
- [Poetry Documentation](https://python-poetry.org/docs/) - Full project manager
- [PDM Documentation](https://pdm-project.org/) - Modern package manager
- [Pipenv Documentation](https://pipenv.pypa.io/) - Legacy tool reference

### Package Standards

- [PEP 517 - Build Backend](https://peps.python.org/pep-0517/) - Build system specification
- [PEP 518 - pyproject.toml](https://peps.python.org/pep-0518/) - Build system requirements
- [PEP 621 - Project Metadata](https://peps.python.org/pep-0621/) - pyproject.toml metadata
- [PEP 582 - Python Packages](https://peps.python.org/pep-0582/) - **pypackages** directory

### Guides & Comparisons

- [Python Packaging Guide](https://packaging.python.org/en/latest/guides/tool-recommendations/) - Official recommendations
- [Hypermodern Python: Dependencies](https://cjolowicz.github.io/posts/hypermodern-python-02-testing/) - Modern practices
- [Poetry vs Pipenv](https://python-poetry.org/docs/#why-poetry) - Comparison from Poetry team

### Tools & Utilities

- [dependabot](https://github.com/dependabot) - Automated dependency updates
- [renovate](https://github.com/renovatebot/renovate) - Dependency update automation
- [pip-audit](https://github.com/pypa/pip-audit) - Security vulnerability scanner
- [safety](https://github.com/pyupio/safety) - Dependency security checker

### Best Practices

- [Python Packaging Authority](https://www.pypa.io/) - Community standards
- [PyPI Publishing Guide](https://packaging.python.org/en/latest/tutorials/packaging-projects/) - Official tutorial

---

## âœ… Learning Checklist

### Traditional pip Workflow

- [ ] Create virtual environment: `python -m venv .venv`
- [ ] Activate virtual environment
- [ ] Install packages: `pip install requests pydantic`
- [ ] Generate requirements: `pip freeze > requirements.txt`
- [ ] Install from requirements: `pip install -r requirements.txt`
- [ ] Understand limitations of requirements.txt (mixes direct and transitive deps)
- [ ] Understand why reproducibility matters for production

### pip-tools Workflow

- [ ] Install pip-tools: `pip install pip-tools`
- [ ] Create `requirements.in` with direct dependencies only
- [ ] Compile to `requirements.txt`: `pip-compile requirements.in`
- [ ] Install exact versions: `pip-sync requirements.txt`
- [ ] Upgrade specific package: `pip-compile --upgrade-package requests`
- [ ] Understand difference between .in (direct) and .txt (locked)
- [ ] Review generated comments showing dependency tree
- [ ] Commit both files to git

### uv - Modern Fast Tool

- [ ] Install uv: `curl -LsSf https://astral.sh/uv/install.sh | sh`
- [ ] Create venv: `uv venv`
- [ ] Activate venv: `source .venv/bin/activate`
- [ ] Install packages: `uv pip install requests`
- [ ] Compile requirements: `uv pip compile requirements.in -o requirements.txt`
- [ ] Sync environment: `uv pip sync requirements.txt`
- [ ] Experience the speed difference vs pip
- [ ] Verify uv works as drop-in replacement for pip

### Poetry Workflow

- [ ] Install Poetry: `curl -sSL https://install.python-poetry.org | python3 -`
- [ ] Initialize new project: `poetry new my-project` or `poetry init`
- [ ] Add dependency: `poetry add requests`
- [ ] Add dev dependency: `poetry add --group dev pytest`
- [ ] Install all dependencies: `poetry install`
- [ ] Update dependencies: `poetry update`
- [ ] View dependency tree: `poetry show --tree`
- [ ] Run commands: `poetry run python script.py`
- [ ] Activate shell: `poetry shell`
- [ ] Build package: `poetry build`
- [ ] Understand pyproject.toml and poetry.lock
- [ ] Commit poetry.lock to version control

### PDM Workflow

- [ ] Install PDM: `curl -sSL https://pdm-project.org/install-pdm.py | python3 -`
- [ ] Initialize project: `pdm init`
- [ ] Add dependency: `pdm add requests`
- [ ] Add dev dependency: `pdm add -dG test pytest`
- [ ] Install dependencies: `pdm install`
- [ ] Run commands: `pdm run python script.py`
- [ ] View dependency tree: `pdm show --graph`
- [ ] (Optional) Try PEP 582 mode: `pdm config python.use_venv false`
- [ ] Understand PEP 621 format

### Version Constraints

- [ ] Understand caret (^): `^2.7` means `>=2.7.0,<3.0.0`
- [ ] Understand tilde (~): `~2.7` means `>=2.7.0,<2.8.0`
- [ ] Use exact versions for production stability
- [ ] Use flexible versions for dev dependencies
- [ ] Understand when each constraint is appropriate

### Best Practices

- [ ] Always commit lockfiles to version control
- [ ] Separate direct dependencies from transitive ones
- [ ] Use dependency groups for test/dev/docs
- [ ] Pin versions for production deployments
- [ ] Document setup instructions in README
- [ ] Run security audits: `pip-audit` or `safety check`
- [ ] Set up dependabot or renovate for automated updates

### Tool Selection

- [ ] Evaluate project needs (simple script vs library vs application)
- [ ] Choose uv or pip-tools for simple, fast workflows
- [ ] Choose Poetry for full project management and publishing
- [ ] Choose PDM for modern PEP 621 workflow
- [ ] Understand why Pipenv is not recommended for new projects
- [ ] Make explicit tool choice and document in README

### Validation

- [ ] **Test**: Create project with pip-tools, compile requirements, sync environment
- [ ] **Test**: Create project with uv, verify the speed advantage
- [ ] **Test**: Create project with Poetry, add deps, build package
- [ ] **Test**: Upgrade a specific dependency and review lockfile changes
- [ ] **Test**: Set up CI/CD to install from lockfile for reproducible builds
- [ ] **Test**: Migrate between two tools successfully
- [ ] **Test**: Run security audit and update vulnerable packages

---

## Quick Reference: Tool Selection

**Need only pip?**
```bash
python -m venv .venv
pip install -r requirements.txt
```

**Need reproducibility + speed?**
```bash
uv pip compile requirements.in
uv pip sync requirements.txt
```

**Publishing to PyPI?**
```bash
poetry new my-project
poetry add requests
poetry build
poetry publish
```

**Modern PEP 621 workflow?**
```bash
pdm init
pdm add requests
pdm install
```

---

*Last updated: 2025-11-10*
